{
  "api/ThomasonAlgorithm.Core.Algorithm.LollipopAlgorithm.html": {
    "href": "api/ThomasonAlgorithm.Core.Algorithm.LollipopAlgorithm.html",
    "title": "Class LollipopAlgorithm | Thomason Algorithm Documentation",
    "summary": "Class LollipopAlgorithm Provides a static implementation of Thomason's Lollipop Algorithm for transforming an existing Hamiltonian cycle in a cubic graph into a second distinct Hamiltonian cycle. Inheritance object LollipopAlgorithm Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: ThomasonAlgorithm.Core.Algorithm Assembly: ThomasonAlgorithm.Core.dll Syntax public static class LollipopAlgorithm Remarks The algorithm requires a valid Hamiltonian cycle to be provided as input. It modifies a copy of the input cycle without altering the original, allowing non-destructive exploration of Hamiltonian paths. It is assumed that the input Hamiltonian cycle starts at vertex 0. The first edge removed during the algorithm's execution is (0, n-1). Methods | Edit this page View Source CreateLollipopVisualization(int[,]) Generates interactive visualization of the lollipop algorithm from an adjacency matrix. Declaration public static void CreateLollipopVisualization(int[,] adjacencyMatrix) Parameters Type Name Description int[,] adjacencyMatrix The adjacency matrix representing a cubic graph. Requirements: 3-regular graph matrix (each vertex has degree 3) Square matrix with consistent connectivity Remarks Creates a complete visualization package in the calling project's root directory under VisualizeSteps/ containing: index.html - Interactive visualization viewer steps.json - Complete algorithm execution trace The visualization demonstrates: Hamiltonian cycle reconstruction process Graph transformations during lollipop operations Edge substitutions and cycle extensions Examples int[,] matrix = new int[,] { {0,1,1,1}, {1,0,1,1}, {1,1,0,1}, {1,1,1,0} }; LollipopVisualizer.CreateLollipopVisualization(matrix); Exceptions Type Condition ArgumentNullException Thrown when adjacencyMatrix is null ArgumentException Thrown when matrix doesn't represent a valid cubic graph | Edit this page View Source CreateLollipopVisualization(string) Generates interactive visualization of the lollipop algorithm from a compressed neighbor list string. Declaration public static void CreateLollipopVisualization(string stringOfNeighbors) Parameters Type Name Description string stringOfNeighbors Compressed string representation of graph connectivity with: Underscore-delimited vertex entries Exactly 3 comma-separated neighbors per vertex Zero-based vertex numbering Symmetric relationships (if A lists B, B must list A) Remarks Creates a complete visualization package in the calling project's root directory under VisualizeSteps/ containing: index.html - Interactive visualization viewer steps.json - Complete algorithm execution trace Input String Format: Vertex neighbors are separated by underscores (_) Each vertex entry contains exactly 3 comma-separated neighbor indices Vertex numbering starts at 0 Example: 0,1,2_1,0,3_2,0,3_3,1,2 for a 4-vertex cubic graph The visualization demonstrates: Hamiltonian cycle reconstruction process Graph transformations during lollipop operations Edge substitutions and cycle extensions Examples For a cube graph: string cubeNeighbors = \"0,1,4_1,0,2,5_2,1,3,6_3,2,7_4,0,5,7_5,1,4,6_6,2,5,7_7,3,4,6\"; LollipopVisualizer.CreateLollipopVisualization(cubeNeighbors); Exceptions Type Condition ArgumentNullException Thrown when input string is null FormatException Thrown when: String doesn't match expected pattern Vertex has incorrect number of neighbors Contains non-numeric values ArgumentException Thrown when: Neighbor list doesn't form a valid cubic graph Graph is not 3-regular Asymmetric relationships detected | Edit this page View Source CreateLollipopVisualization(CubicGraphWithCycle) Generates interactive visualization files for the lollipop algorithm's execution on a cubic graph. Declaration public static void CreateLollipopVisualization(CubicGraphWithCycle cubicGraphWithCycle) Parameters Type Name Description CubicGraphWithCycle cubicGraphWithCycle The input cubic graph with Hamiltonian cycle to visualize. Requires: Valid HamiltonianCycle containing at least 3 vertices Consistent Graph adjacency matrix matching the cycle Remarks This method creates a complete visualization package consisting of: A VisualizeSteps directory created at the root of the calling project index.html - Self-contained visualization viewer with interactive controls steps.json - Complete algorithm execution trace with graph state at each step The visualization allows examining: The complete Hamiltonian cycle reconstruction process Intermediate graph states during cycle extension Edge transformations during the lollipop operation Examples Basic usage: var graph = CubicGraphWithCycle.FromAdjacencyMatrix(matrix, cycle); LollipopVisualizer.CreateLollipopVisualization(graph); // Opens visualization at: [ProjectRoot]/VisualizeSteps/index.html Exceptions Type Condition ArgumentNullException Thrown when cubicGraphWithCycle or its essential components are null InvalidOperationException Thrown when the graph and cycle fail validation checks | Edit this page View Source FindSecondHamiltonianCycleAndReturnSteps(CubicGraphWithCycle) Applies the Thomason's lollipop algorithm to reconstruct a second Hamiltonian cycle from the one provided in the CubicGraphWithCycle instance, and returns the number of steps taken by the algorithm. Declaration public static int FindSecondHamiltonianCycleAndReturnSteps(CubicGraphWithCycle cubicGraphWithCycle) Parameters Type Name Description CubicGraphWithCycle cubicGraphWithCycle An object that encapsulates a cubic graph and one of its Hamiltonian cycles. Returns Type Description int The number of steps performed by the algorithm during the reconstruction of the second cycle. Remarks The provided Hamiltonian cycle will be modified in-place to represent the second Hamiltonian cycle. Make sure to pass a deep copy if the original cycle should be preserved. | Edit this page View Source FindSecondHamiltonianCycleAndVisualize(int[,]) Constructs a cubic graph from the given adjacency matrix, computes an initial Hamiltonian cycle, and finds the second Hamiltonian cycle using Thomason’s algorithm, producing visualization steps. Declaration public static void FindSecondHamiltonianCycleAndVisualize(int[,] adjacencyMatrix) Parameters Type Name Description int[,] adjacencyMatrix A square 2D array representing the adjacency matrix of a cubic graph (each row contains exactly 3 ones). | Edit this page View Source FindSecondHamiltonianCycleAndVisualize(string) Parses a cubic graph from a compact string representation of neighbor lists, constructs an initial Hamiltonian cycle, and applies Thomason’s algorithm to find a second Hamiltonian cycle while collecting visualization steps. Declaration public static void FindSecondHamiltonianCycleAndVisualize(string stringOfNeighbors) Parameters Type Name Description string stringOfNeighbors A string where each vertex’s neighbors are given as comma-separated integers, and each vertex entry is separated by an underscore ''. For example: \"1,2,3_0,2,4_0,1,5...\" represents a graph where vertex 0 is connected to 1, 2, 3, vertex 1 is connected to 0, 2, 4, and so on. Remarks Internally uses GetMatrixFromNeighborsString(string) to convert the string into an adjacency matrix. | Edit this page View Source FindSecondHamiltonianCycleAndVisualize(CubicGraphWithCycle) Finds the second Hamiltonian cycle in a cubic graph that already includes an initial Hamiltonian cycle, and collects visualization steps for the transformation using Thomason’s algorithm. Declaration public static void FindSecondHamiltonianCycleAndVisualize(CubicGraphWithCycle cubicGraphWithCycle) Parameters Type Name Description CubicGraphWithCycle cubicGraphWithCycle A CubicGraphWithCycle instance containing both the cubic graph and its initial Hamiltonian cycle. | Edit this page View Source GetHamiltonianCycleSequencedVertices(Dictionary<int, List<int>>) Gets the set of vertices in the Hamiltonian cycle, ordered in the sequence they appear in the cycle, starting from vertex 0. Declaration public static HashSet<int> GetHamiltonianCycleSequencedVertices(Dictionary<int, List<int>> hamiltonianCycle) Parameters Type Name Description Dictionary<int, List<int>> hamiltonianCycle A dictionary representing the Hamiltonian cycle, where each vertex is mapped to its list of neighbors in the cycle. Returns Type Description HashSet<int> A HashSet<T> containing the vertices of the Hamiltonian cycle in the order they appear in the cycle starting from 0."
  },
  "api/ThomasonAlgorithm.Core.Algorithm.html": {
    "href": "api/ThomasonAlgorithm.Core.Algorithm.html",
    "title": "Namespace ThomasonAlgorithm.Core.Algorithm | Thomason Algorithm Documentation",
    "summary": "Namespace ThomasonAlgorithm.Core.Algorithm Classes LollipopAlgorithm Provides a static implementation of Thomason's Lollipop Algorithm for transforming an existing Hamiltonian cycle in a cubic graph into a second distinct Hamiltonian cycle."
  },
  "api/ThomasonAlgorithm.Core.Extensions.ListExtensions.html": {
    "href": "api/ThomasonAlgorithm.Core.Extensions.ListExtensions.html",
    "title": "Class ListExtensions | Thomason Algorithm Documentation",
    "summary": "Class ListExtensions Provides extension methods for List<T> collections. Inheritance object ListExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: ThomasonAlgorithm.Core.Extensions Assembly: ThomasonAlgorithm.Core.dll Syntax public static class ListExtensions Remarks This class contains utility methods that extend the functionality of generic lists, particularly for graph algorithm operations and neighbor searching scenarios. Examples Basic usage: var neighbors = new List<int> { 1, 2, 3 }; var result = neighbors.FirstPossibleNeighborOrNull(x => x > 1); // Returns 2 Methods | Edit this page View Source FirstPossibleNeighborOrNull(List<int>, Func<int, bool>) Returns the first element in the list that satisfies the specified predicate, or null if no such element exists. Declaration public static int? FirstPossibleNeighborOrNull(this List<int> source, Func<int, bool> predicate) Parameters Type Name Description List<int> source The list of integers to search through. Func<int, bool> predicate The predicate function used to test each element. Returns Type Description int? The first element that matches the predicate, or null if no matching element is found. Exceptions Type Condition ArgumentNullException Thrown if source or predicate is null."
  },
  "api/ThomasonAlgorithm.Core.Extensions.html": {
    "href": "api/ThomasonAlgorithm.Core.Extensions.html",
    "title": "Namespace ThomasonAlgorithm.Core.Extensions | Thomason Algorithm Documentation",
    "summary": "Namespace ThomasonAlgorithm.Core.Extensions Classes ListExtensions Provides extension methods for List<T> collections."
  },
  "api/ThomasonAlgorithm.Core.GraphGenerators.RandomCubicGraphGenerator.html": {
    "href": "api/ThomasonAlgorithm.Core.GraphGenerators.RandomCubicGraphGenerator.html",
    "title": "Class RandomCubicGraphGenerator | Thomason Algorithm Documentation",
    "summary": "Class RandomCubicGraphGenerator A utility class for generating random cubic (3-regular) graphs with a specified number of vertices. The generated graph ensures that each vertex has exactly 3 neighbors, adhering to the properties of a cubic graph. Additionally, this class provides methods for generating cubic graphs with various constraints on chord lengths. Inheritance object RandomCubicGraphGenerator Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: ThomasonAlgorithm.Core.GraphGenerators Assembly: ThomasonAlgorithm.Core.dll Syntax public static class RandomCubicGraphGenerator Methods | Edit this page View Source GenerateGraphFromExactChordsSet(int, int, int, Dictionary<int, int>, int) Generates a cubic graph (3-regular graph) with a precise number of chords for each specified chord length. Declaration public static CubicGraph? GenerateGraphFromExactChordsSet(int n, int kLow, int kUp, Dictionary<int, int> chordsLengthDictionary, int maxAttempts = 100) Parameters Type Name Description int n The number of vertices in the graph. Must be an even number ≥ 4. int kLow The minimum allowed chord length. int kUp The maximum allowed chord length. Dictionary<int, int> chordsLengthDictionary A dictionary mapping chord lengths to the exact number of chords of that length that must appear in the graph. int maxAttempts The maximum number of attempts to generate a valid graph. Default is 100. Returns Type Description CubicGraph A cubic graph that matches the exact chord length distribution if one is found within the allowed attempts; otherwise, returns null. | Edit this page View Source GenerateGraphLimitedChords(int, int, int, int) Generates a cubic graph (3-regular graph) where chord lengths are restricted to be within the inclusive range [kLow, kUp]. Declaration public static CubicGraph? GenerateGraphLimitedChords(int n, int kLow, int kUp, int maxAttempts = 100) Parameters Type Name Description int n The number of vertices in the graph. Must be an even number ≥ 4. int kLow The minimum allowed chord length (inclusive). int kUp The maximum allowed chord length (inclusive). int maxAttempts Maximum number of attempts to generate a valid graph. Default is 100. Returns Type Description CubicGraph A cubic graph where all chords have lengths within the range [kLow, kUp], or null if generation fails within the given number of attempts. | Edit this page View Source GenerateGraphWithGapInChordLengths(int, int, int, Gap, int) Generates a cubic graph (3-regular graph) where chord lengths are within the specified range kLow to kUp, but exclude a specific gap range. Declaration public static CubicGraph? GenerateGraphWithGapInChordLengths(int n, int kLow, int kUp, Gap gap, int maxAttempts = 100) Parameters Type Name Description int n The number of vertices in the graph. Must be an even number ≥ 4. int kLow The minimum allowed chord length. int kUp The maximum allowed chord length. Gap gap A Gap struct specifying the range of chord lengths to exclude from the graph. For example, if the gap is [5–7], then chords of lengths 5, 6, and 7 will be excluded. int maxAttempts Maximum number of attempts to generate a valid graph. Default is 100. Returns Type Description CubicGraph A cubic graph that avoids the specified gap in chord lengths, or null if no valid graph is found within the allowed number of attempts. | Edit this page View Source GenerateGraphWithOddLengthChords(int, int, int, int) Generates a cubic graph (3-regular graph) where only chords of odd lengths within the given bounds are allowed. The resulting graph is guaranteed to be bipartite due to the restriction on odd-length chords. Declaration public static CubicGraph? GenerateGraphWithOddLengthChords(int n, int kLow, int kUp, int maxAttempts = 100) Parameters Type Name Description int n The number of vertices in the graph. Must be an even number ≥ 4. int kLow The minimum chord length (inclusive). int kUp The maximum chord length (inclusive). int maxAttempts Maximum number of attempts to generate a valid graph. Default is 100. Returns Type Description CubicGraph A bipartite cubic graph containing only odd-length chords in the range [kLow, kUp], or null if generation fails within the given number of attempts."
  },
  "api/ThomasonAlgorithm.Core.GraphGenerators.html": {
    "href": "api/ThomasonAlgorithm.Core.GraphGenerators.html",
    "title": "Namespace ThomasonAlgorithm.Core.GraphGenerators | Thomason Algorithm Documentation",
    "summary": "Namespace ThomasonAlgorithm.Core.GraphGenerators Classes RandomCubicGraphGenerator A utility class for generating random cubic (3-regular) graphs with a specified number of vertices. The generated graph ensures that each vertex has exactly 3 neighbors, adhering to the properties of a cubic graph. Additionally, this class provides methods for generating cubic graphs with various constraints on chord lengths."
  },
  "api/ThomasonAlgorithm.Core.Graphs.CubicGraph.html": {
    "href": "api/ThomasonAlgorithm.Core.Graphs.CubicGraph.html",
    "title": "Class CubicGraph | Thomason Algorithm Documentation",
    "summary": "Class CubicGraph Represents a cubic (3-regular) graph, where each vertex has exactly 3 neighbors. This class manages the graph structure, chord lengths, and Hamiltonian cycle. Inheritance object Graph CubicGraph Inherited Members Graph.AdjacencyMatrix Graph.VertexCount Graph.HasEdge(int, int) Graph.RemoveEdge(int, int) Graph.GetVertexDegree(int) Graph.GetNeighbors(int) Graph.IsRegular(int) Graph.IsCubic() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: ThomasonAlgorithm.Core.Graphs Assembly: ThomasonAlgorithm.Core.dll Syntax public class CubicGraph : Graph Constructors | Edit this page View Source CubicGraph(int[,]) Initializes a new instance of the CubicGraph class using the provided adjacency matrix. Declaration public CubicGraph(int[,] adjacencyMatrix) Parameters Type Name Description int[,] adjacencyMatrix A square matrix representing the adjacency structure of the graph. Remarks This constructor ensures that the input graph is cubic at the time of initialization. It also computes the chord lengths for all applicable node pairs and sets the maximum chord length found in the graph. Exceptions Type Condition ArgumentOutOfRangeException Thrown if the provided adjacency matrix does not correspond to a valid cubic graph, i.e., each vertex must have exactly three edges. Fields | Edit this page View Source ChordsLengths Dictionary holding the chord lengths and the number of times each chord length occurs. Declaration public readonly Dictionary<int, int> ChordsLengths Field Value Type Description Dictionary<int, int> | Edit this page View Source MaxChordLength Gets or sets the maximum chord length found in the graph. Declaration public int MaxChordLength Field Value Type Description int Properties | Edit this page View Source HamiltonianCycle Stores the Hamiltonian cycle of the graph, represented as a dictionary of vertices and their neighbors in the cycle. Declaration public Dictionary<int, List<int>>? HamiltonianCycle { get; set; } Property Value Type Description Dictionary<int, List<int>> Methods | Edit this page View Source AddEdge(int, int) Adds an edge between two vertices, ensuring the graph remains cubic (3-regular). Declaration public void AddEdge(int from, int to) Parameters Type Name Description int from The starting vertex of the edge. int to The ending vertex of the edge. Exceptions Type Condition InvalidOperationException Thrown if an edge already exists or the degree of a vertex exceeds 3."
  },
  "api/ThomasonAlgorithm.Core.Graphs.CubicGraphWithCycle.html": {
    "href": "api/ThomasonAlgorithm.Core.Graphs.CubicGraphWithCycle.html",
    "title": "Class CubicGraphWithCycle | Thomason Algorithm Documentation",
    "summary": "Class CubicGraphWithCycle Represents a cubic graph with an associated Hamiltonian cycle. Provides functionality to initialize the graph with or without a provided cycle. Inheritance object CubicGraphWithCycle Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: ThomasonAlgorithm.Core.Graphs Assembly: ThomasonAlgorithm.Core.dll Syntax public class CubicGraphWithCycle Remarks This class ensures that a Hamiltonian cycle is explicitly associated with a specific cubic graph, providing better consistency and clarity when passing this data between methods or components. Constructors | Edit this page View Source CubicGraphWithCycle(CubicGraph) Initializes a new instance of CubicGraphWithCycle with a generated Hamiltonian cycle. Declaration public CubicGraphWithCycle(CubicGraph graph) Parameters Type Name Description CubicGraph graph The cubic graph for which to generate a Hamiltonian cycle. Remarks Automatically generates a trivial Hamiltonian cycle using CreateCubicGraphHamiltonianCycle(CubicGraph). The generated cycle connects vertices in sequential order (0→1→2...→n-1→0). For non-trivial cycles, use the constructor that accepts a precomputed cycle. Examples var graph = new CubicGraph(adjacencyMatrix); var graphWithCycle = new CubicGraphWithCycle(graph); // Generates default cycle Exceptions Type Condition ArgumentNullException Thrown when graph is null. ArgumentOutOfRangeException Thrown when the graph is not cubic (any vertex doesn't have degree 3). See Also CreateCubicGraphHamiltonianCycle(CubicGraph) | Edit this page View Source CubicGraphWithCycle(CubicGraph, Dictionary<int, List<int>>) Initializes a new instance of CubicGraphWithCycle with a specified Hamiltonian cycle. Declaration public CubicGraphWithCycle(CubicGraph graph, Dictionary<int, List<int>> cycle) Parameters Type Name Description CubicGraph graph The cubic graph to associate with the cycle. Dictionary<int, List<int>> cycle A dictionary representing the Hamiltonian cycle where: Keys are vertex indices Values are lists of exactly 2 connected vertices Remarks Use this constructor when you have a precomputed Hamiltonian cycle for the graph. The cycle will be used as-is without validation. The cycle must: Contain all vertices of the graph exactly once Form a single connected loop Maintain cubic graph properties Examples var graph = new CubicGraph(adjacencyMatrix); var precomputedCycle = new Dictionary<int, List<int>>() { ... }; var graphWithCycle = new CubicGraphWithCycle(graph, precomputedCycle); Exceptions Type Condition ArgumentNullException Thrown when either graph or cycle is null. Properties | Edit this page View Source Graph Gets the underlying cubic graph associated with this instance. Declaration public CubicGraph Graph { get; } Property Value Type Description CubicGraph A CubicGraph object representing the graph structure. Remarks The graph maintains these properties: 3-regular (each vertex has degree 3) Undirected (edges are bidirectional) No self-loops | Edit this page View Source HamiltonianCycle Gets the Hamiltonian cycle associated with the graph. Declaration public Dictionary<int, List<int>> HamiltonianCycle { get; } Property Value Type Description Dictionary<int, List<int>> A dictionary mapping each vertex to its two adjacent vertices in the cycle. Remarks The cycle is represented as an adjacency dictionary where: Keys are vertex indices (0-based) Values are lists containing exactly 2 connected vertices This ensures the cycle forms a single loop through all vertices. Examples For a 4-vertex cycle: { 0:[3,1], 1:[0,2], 2:[1,3], 3:[2,0] }"
  },
  "api/ThomasonAlgorithm.Core.Graphs.Graph.html": {
    "href": "api/ThomasonAlgorithm.Core.Graphs.Graph.html",
    "title": "Class Graph | Thomason Algorithm Documentation",
    "summary": "Class Graph Represents an unweighted, undirected graph data structure using an adjacency matrix. Inheritance object Graph CubicGraph Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: ThomasonAlgorithm.Core.Graphs Assembly: ThomasonAlgorithm.Core.dll Syntax public class Graph Remarks This class provides a foundation for graph operations using a square matrix to represent vertex connections in an unweighted, undirected graph. The matrix is immutable after construction. Key characteristics: Unweighted edges (values are 0 or 1) Undirected (matrix is always symmetric) No self-loops (diagonal elements are always 0) Constructors | Edit this page View Source Graph(int) Initializes a new unweighted, undirected graph with the specified number of vertices. Declaration public Graph(int size) Parameters Type Name Description int size The number of vertices in the graph. Must be a positive integer greater than 0. Remarks Creates an empty adjacency matrix where: All elements are initialized to 0 (no edges) Matrix dimensions are size × size Will remain symmetric (undirected) when edges are added Examples Create a 5-vertex graph: var graph = new Graph(5); // Creates 5x5 matrix initialized with zeros Exceptions Type Condition ArgumentOutOfRangeException Thrown when size is less than 1. | Edit this page View Source Graph(int[,]) Initializes a new instance of the Graph class using the provided adjacency matrix. Declaration public Graph(int[,] adjacencyMatrix) Parameters Type Name Description int[,] adjacencyMatrix A square, binary, symmetric matrix representing the adjacency structure of the graph. Elements are 0 (no edge) or 1 (edge exists). Remarks This constructor creates an unweighted, undirected graph based on the provided adjacency matrix. The matrix is cloned to prevent external modifications and ensure immutability after initialization. The adjacency matrix must satisfy the following conditions: Must be non-null Must be square (n × n) Must be binary (contain only 0 or 1) Must be symmetric (matrix[i,j] == matrix[j,i]) Must have zero diagonal (no self-loops, matrix[i,i] == 0) Examples Create a graph from a 3-vertex adjacency matrix: int[,] matrix = new int[,] { {0, 1, 0}, {1, 0, 1}, {0, 1, 0} }; var graph = new Graph(matrix); Exceptions Type Condition ArgumentNullException Thrown when adjacencyMatrix is null. ArgumentException Thrown when adjacencyMatrix is not square, not binary, not symmetric, or contains non-zero diagonal elements. Fields | Edit this page View Source AdjacencyMatrix The adjacency matrix representing connections between vertices in an unweighted, undirected graph. Declaration public readonly int[,] AdjacencyMatrix Field Value Type Description int[,] Remarks Matrix characteristics: 0 indicates no edge between vertices 1 indicates an existing edge (unweighted) Symmetric (matrix[i,j] == matrix[j,i] for undirected graphs) Zero diagonal (matrix[i,i] == 0, no self-loops) This field is readonly - the matrix reference cannot be reassigned, though individual elements can be modified through controlled methods like AddEdge(int, int). Properties | Edit this page View Source VertexCount Gets the total number of vertices in the graph. Declaration public int VertexCount { get; } Property Value Type Description int Methods | Edit this page View Source AddEdge(int, int) Adds an edge between two vertices Declaration public void AddEdge(int from, int to) Parameters Type Name Description int from The starting vertex of the edge. int to The ending vertex of the edge. Exceptions Type Condition InvalidOperationException Thrown if an edge already exists. | Edit this page View Source GetNeighbors(int) Gets the list of neighbors (vertices connected by edges) for a specified vertex. Declaration public List<int> GetNeighbors(int vertex) Parameters Type Name Description int vertex The vertex for which neighbors are to be retrieved. Returns Type Description List<int> A list of neighboring vertices. | Edit this page View Source GetVertexDegree(int) Gets the degree of a vertex (the number of edges connected to it). Declaration public int GetVertexDegree(int vertex) Parameters Type Name Description int vertex The vertex whose degree is to be calculated. Returns Type Description int The degree of the specified vertex. | Edit this page View Source HasEdge(int, int) Checks whether an edge exists between two vertices. Declaration public bool HasEdge(int from, int to) Parameters Type Name Description int from The starting vertex of the edge. int to The ending vertex of the edge. Returns Type Description bool True if an edge exists between the two vertices; otherwise, false. | Edit this page View Source IsCubic() Determines whether the graph is cubic (3-regular). Declaration public bool IsCubic() Returns Type Description bool true if the graph is cubic (all vertices have degree 3); otherwise, false. Remarks A cubic graph is a 3-regular graph where every vertex has exactly three edges. This is equivalent to calling IsRegular(int) with parameter 3. Examples Basic usage: if (graph.IsCubic()) { Console.WriteLine(\"The graph is cubic\"); } | Edit this page View Source IsRegular(int) Determines whether the graph is regular with the specified degree for all vertices. Declaration public bool IsRegular(int regularity) Parameters Type Name Description int regularity The expected degree for all vertices in the graph. Returns Type Description bool true if every vertex in the graph has degree equal to regularity; otherwise, false. Remarks A graph is called regularity-regular if every vertex has exactly regularity edges. Common cases include: 3-regular (cubic) graphs 2-regular (cycle graphs) 1-regular (perfect matching graphs) Examples Check if a graph is cubic (3-regular): if (graph.IsRegular(3)) { Console.WriteLine(\"The graph is cubic\"); } | Edit this page View Source RemoveEdge(int, int) Removes an edge between two vertices. Declaration public void RemoveEdge(int from, int to) Parameters Type Name Description int from The starting vertex of the edge. int to The ending vertex of the edge."
  },
  "api/ThomasonAlgorithm.Core.Graphs.IGraph.html": {
    "href": "api/ThomasonAlgorithm.Core.Graphs.IGraph.html",
    "title": "Interface IGraph | Thomason Algorithm Documentation",
    "summary": "Interface IGraph Namespace: ThomasonAlgorithm.Core.Graphs Assembly: ThomasonAlgorithm.Core.dll Syntax public interface IGraph Properties | Edit this page View Source VertexCount Declaration int VertexCount { get; } Property Value Type Description int Methods | Edit this page View Source AddEdge(int, int) Declaration void AddEdge(int from, int to) Parameters Type Name Description int from int to | Edit this page View Source GetNeighbors(int) Declaration List<int> GetNeighbors(int vertex) Parameters Type Name Description int vertex Returns Type Description List<int> | Edit this page View Source GetVertexDegree(int) Declaration int GetVertexDegree(int vertex) Parameters Type Name Description int vertex Returns Type Description int | Edit this page View Source HasEdge(int, int) Declaration bool HasEdge(int from, int to) Parameters Type Name Description int from int to Returns Type Description bool | Edit this page View Source RemoveEdge(int, int) Declaration void RemoveEdge(int from, int to) Parameters Type Name Description int from int to"
  },
  "api/ThomasonAlgorithm.Core.Graphs.html": {
    "href": "api/ThomasonAlgorithm.Core.Graphs.html",
    "title": "Namespace ThomasonAlgorithm.Core.Graphs | Thomason Algorithm Documentation",
    "summary": "Namespace ThomasonAlgorithm.Core.Graphs Classes CubicGraph Represents a cubic (3-regular) graph, where each vertex has exactly 3 neighbors. This class manages the graph structure, chord lengths, and Hamiltonian cycle. CubicGraphWithCycle Represents a cubic graph with an associated Hamiltonian cycle. Provides functionality to initialize the graph with or without a provided cycle. Graph Represents an unweighted, undirected graph data structure using an adjacency matrix."
  },
  "api/ThomasonAlgorithm.Core.Models.Gap.html": {
    "href": "api/ThomasonAlgorithm.Core.Models.Gap.html",
    "title": "Class Gap | Thomason Algorithm Documentation",
    "summary": "Class Gap Represents a range (gap) of integer values with a specified lower and upper bound. This is used to define a range of chord lengths to exclude or consider in graph generation. Inheritance object Gap Implements IEquatable<Gap> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Namespace: ThomasonAlgorithm.Core.Models Assembly: ThomasonAlgorithm.Core.dll Syntax public sealed record Gap : IEquatable<Gap> Constructors | Edit this page View Source Gap(int, int) Represents a range (gap) of integer values with a specified lower and upper bound. This is used to define a range of chord lengths to exclude or consider in graph generation. Declaration public Gap(int LeftBound, int RightBound) Parameters Type Name Description int LeftBound The inclusive lower bound of the gap range. int RightBound The inclusive upper bound of the gap range. Properties | Edit this page View Source LeftBound The inclusive lower bound of the gap range. Declaration public int LeftBound { get; init; } Property Value Type Description int | Edit this page View Source RightBound The inclusive upper bound of the gap range. Declaration public int RightBound { get; init; } Property Value Type Description int Implements IEquatable<T>"
  },
  "api/ThomasonAlgorithm.Core.Models.LollipopStep.html": {
    "href": "api/ThomasonAlgorithm.Core.Models.LollipopStep.html",
    "title": "Class LollipopStep | Thomason Algorithm Documentation",
    "summary": "Class LollipopStep Represents a single step in the reconstruction of a Hamiltonian cycle during the execution of the Thomason (lollipop) algorithm. Inheritance object LollipopStep Implements IEquatable<LollipopStep> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Namespace: ThomasonAlgorithm.Core.Models Assembly: ThomasonAlgorithm.Core.dll Syntax public record LollipopStep : IEquatable<LollipopStep> Constructors | Edit this page View Source LollipopStep(List<List<int>>, List<int>?, List<int>?) Represents a single step in the reconstruction of a Hamiltonian cycle during the execution of the Thomason (lollipop) algorithm. Declaration public LollipopStep(List<List<int>> CurrentCycleEdges, List<int>? AddedEdge, List<int>? RemovedEdge) Parameters Type Name Description List<List<int>> CurrentCycleEdges A list of edges (each as a pair of vertex indices) that form the current Hamiltonian cycle or path at this step. List<int> AddedEdge The edge that was added to the cycle in this step, if any. Represented as a list of two vertex indices. Null if no edge was added in this step. List<int> RemovedEdge The edge that was removed from the cycle in this step, if any. Represented as a list of two vertex indices. Null if no edge was removed in this step (e.g., the final step that completes the cycle). Properties | Edit this page View Source AddedEdge The edge that was added to the cycle in this step, if any. Represented as a list of two vertex indices. Null if no edge was added in this step. Declaration public List<int>? AddedEdge { get; init; } Property Value Type Description List<int> | Edit this page View Source CurrentCycleEdges A list of edges (each as a pair of vertex indices) that form the current Hamiltonian cycle or path at this step. Declaration public List<List<int>> CurrentCycleEdges { get; init; } Property Value Type Description List<List<int>> | Edit this page View Source RemovedEdge The edge that was removed from the cycle in this step, if any. Represented as a list of two vertex indices. Null if no edge was removed in this step (e.g., the final step that completes the cycle). Declaration public List<int>? RemovedEdge { get; init; } Property Value Type Description List<int> Implements IEquatable<T>"
  },
  "api/ThomasonAlgorithm.Core.Models.html": {
    "href": "api/ThomasonAlgorithm.Core.Models.html",
    "title": "Namespace ThomasonAlgorithm.Core.Models | Thomason Algorithm Documentation",
    "summary": "Namespace ThomasonAlgorithm.Core.Models Classes Gap Represents a range (gap) of integer values with a specified lower and upper bound. This is used to define a range of chord lengths to exclude or consider in graph generation. LollipopStep Represents a single step in the reconstruction of a Hamiltonian cycle during the execution of the Thomason (lollipop) algorithm."
  },
  "articles/experiment-demo.html": {
    "href": "articles/experiment-demo.html",
    "title": "Cubic Graph Experiment Demo | Thomason Algorithm Documentation",
    "summary": "Cubic Graph Experiment Demo See also: Getting Started API Reference Cubic Graph Experiment Demo Overview This demonstration showcases how to use ThomasonAlgorithm.Core to: Generate random cubic graphs with specified constraints Find Hamiltonian cycles using the Lollipop algorithm Store and analyze experiment results in PostgreSQL Prerequisites .NET 8+ SDK PostgreSQL 14+ with JSONB support NuGet packages: dotnet add package Npgsql dotnet add package Microsoft.EntityFrameworkCore dotnet add package ThomasonAlgorithm.Core 1. Data Model Implementation 1.1 Entity Definition public sealed record CubicGraphExperiment { public CubicGraphExperiment(int verticesNumber, int kLow, int kUp, int maxChordLength, int lollipopStepsNumber, Dictionary<int, int> chordLengths) { VerticesNumber = verticesNumber; KLow = kLow; KUp = kUp; MaxChordLength = maxChordLength; LollipopStepsNumber = lollipopStepsNumber; ChordLengths = chordLengths; Timestamp = DateTime.UtcNow; } public Guid Id { get; set; } = Guid.NewGuid(); /// <summary> /// number of vertex in graph /// </summary> [Column(\"vertices_number\")] public int VerticesNumber { get; set; } /// <summary> /// chord length lower limit /// </summary> [Column(\"K_low\")] public int KLow { get; set; } /// <summary> /// chord length upper limit /// </summary> [Column(\"K_up\")] public int KUp { get; set; } /// <summary> /// biggest chord length in graph /// </summary> [Column(\"max_chord_length\")] public int MaxChordLength { get; set; } /// <summary> /// number of steps which algorithm required to find second hamiltonian cycle in presented graph /// </summary> [Column(\"lollipop_steps_number\")] public int LollipopStepsNumber { get; set; } /// <summary> /// chord lengths and its number which exist in graph /// </summary> [Column(\"chord_lengths\", TypeName = \"jsonb\")] public Dictionary<int, int> ChordLengths { get; set; } [Column(\"timestamp\")] public DateTime Timestamp { get; set; } } 1.2 Database Context public class AppDbContext : DbContext { public DbSet<CubicGraphExperiment> CubicGraphExperiments { get; set; } public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { } protected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); modelBuilder.Entity<CubicGraphExperiment>() .HasKey(e => e.Id); modelBuilder.Entity<CubicGraphExperiment>() .Property(x => x.ChordLengths) .HasColumnType(\"jsonb\"); } } 2. Infrastructure Setup 2.1 Database Configuration public static class DependencyInjection { public static IServiceCollection AddDbInfrastructure(this IServiceCollection services, string connectionString) { if (connectionString == null) throw new ArgumentNullException(nameof(connectionString), \"Connection string is required\"); var npgSqlDatasourceBuilder = new NpgsqlDataSourceBuilder(connectionString).EnableDynamicJson().Build(); services.AddDbContext<AppDbContext>(options => options.UseNpgsql(npgSqlDatasourceBuilder).UseSnakeCaseNamingConvention()); return services; } } 2.2 Service Registration // In Program.cs builder.Services.AddDbInfrastructure(\"Host=localhost;Database=graph_db;Username=postgres;Password=your_password\"); 3. Experiment Configuration 3.1 Parameter Validation public sealed record ExperimentOptions { public ExperimentOptions( int maxN, int kLow, int kUp, int maxAttempt = 100, int graphSameSize = 100, int startVerticesNumber = -1) { if (maxN < 2 * kUp) throw new ArgumentOutOfRangeException(nameof(maxN), \"maxN must be greater than or equal to 2 * kUp\"); if (startVerticesNumber != -1 && startVerticesNumber < 2 * kUp) throw new ArgumentOutOfRangeException(nameof(startVerticesNumber), \"startVerticesNumber must be greater than or equal to 2 * kUp\"); if (startVerticesNumber != -1 && startVerticesNumber % 2 != 0) throw new ArgumentOutOfRangeException(nameof(startVerticesNumber), \"startVerticesNumber must be even\"); if (maxN < startVerticesNumber) throw new ArgumentOutOfRangeException(nameof(maxN), \"maxN must be greater than or equal to startVerticesNumber\"); if (kUp < kLow) throw new ArgumentOutOfRangeException(nameof(kUp), \"kUp must be greater than or equal to kLow\"); if (maxAttempt <= 0) throw new ArgumentOutOfRangeException(nameof(maxAttempt), \"maxAttempt must be greater than 0\"); if (graphSameSize <= 0) throw new ArgumentOutOfRangeException(nameof(graphSameSize), \"graphSameSize must be greater than 0\"); MaxN = maxN; KLow = kLow; KUp = kUp; StartVerticesNumber = startVerticesNumber == -1 ? 2 * kUp : startVerticesNumber; MaxAttempt = maxAttempt; GraphSameSize = graphSameSize; } public void Deconstruct( out int maxN, out int kLow, out int kUp, out int startVerticesNumber, out int maxAttempt, out int graphSameSize) { maxN = MaxN; kLow = KLow; kUp = KUp; startVerticesNumber = StartVerticesNumber; maxAttempt = MaxAttempt; graphSameSize = GraphSameSize; } public int MaxN { get; init; } public int KLow { get; init; } public int KUp { get; init; } public int StartVerticesNumber { get; init; } public int MaxAttempt { get; init; } public int GraphSameSize { get; init; } } 4. Core Experiment Service 4.1 Implementation public class CubicGraphExperimentService { public async Task ExperimentCubicGraph(ExperimentOptions options, IHost app) { var (maxN, kLow, kUp, startVerticesNumber, maxAttempt, maxGraphsSameSize) = options; const int batchSize = 1000; const int initialStringBuilderCapacity = 256; var allExperiments = new List<CubicGraphExperiment>(batchSize); using var scope = app.Services.CreateScope(); var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>(); for (var n = startVerticesNumber; n <= maxN; n += 2) { var experiments = new List<CubicGraphExperiment>(maxGraphsSameSize); await Parallel.ForEachAsync(Enumerable.Range(0, maxGraphsSameSize), new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount }, async (graphsSameSize, ct) => { var stringBuilder = new StringBuilder(initialStringBuilderCapacity); var randomCubicGraph = RandomCubicGraphGenerator.GenerateGraphLimitedChords(n, kLow, kUp, maxAttempt); if (randomCubicGraph == null) { lock (Console.Out) { Console.WriteLine(\"Cubic graph was not generated.\"); } return; } var cubicGraphWithCycle = new CubicGraphWithCycle(randomCubicGraph); var lollipopStepsNumber = LollipopAlgorithm.FindSecondHamiltonianCycleAndReturnSteps(cubicGraphWithCycle); stringBuilder.AppendFormat(\"lollipop_steps_number: {0}, for graph with n: {1}, kLow: {2}, kUp: {3}\", lollipopStepsNumber, n, kLow, kUp); lock (Console.Out) { Console.WriteLine(stringBuilder.ToString()); } stringBuilder.Clear(); var experiment = new CubicGraphExperiment(n, kLow, kUp, randomCubicGraph.MaxChordLength, lollipopStepsNumber, randomCubicGraph.ChordsLengths); lock (experiments) { experiments.Add(experiment); } }); allExperiments.AddRange(experiments); if (allExperiments.Count >= batchSize) { await dbContext.BulkInsertAsync(allExperiments); allExperiments.Clear(); } } if (allExperiments.Any()) { await dbContext.BulkInsertAsync(allExperiments); } } } 5. Execution Example Running the Experiment var builder = WebApplication.CreateBuilder(args); builder.Services.AddDbInfrastructure(builder.Configuration.GetConnectionString(\"Default\")); var app = builder.Build(); // Configure experiment parameters var options = new ExperimentOptions( maxN: 1000, kLow: 2, kUp: 10, maxAttempt: 100, graphSameSize: 500); // Execute var experimentService = new CubicGraphExperimentService(); await experimentService.RunExperiment(options, app);"
  },
  "articles/getting-started.html": {
    "href": "articles/getting-started.html",
    "title": "Getting Started | Thomason Algorithm Documentation",
    "summary": "Getting Started 1. Fork the repository: Visit GitHub repository Click \"Fork\" in top-right corner 2. Clone your fork: git clone <url to your fork> \\ cd ThomasonAlgorithm 3. Build the project: dotnet build src/ThomasonAlgorithm.Core --configuration Release 4. Reference locally: For testing in your projects: dotnet add reference ThomasonAlgorithm/src/ThomasonAlgorithm.Core/ThomasonAlgorithm.Core.csproj"
  },
  "articles/lollipop-visualization-demo.html": {
    "href": "articles/lollipop-visualization-demo.html",
    "title": "Graph Visualization Example | Thomason Algorithm Documentation",
    "summary": "Graph Visualization Example Purpose: Demonstrates how to generate step-by-step visualizations of the Lollipop Algorithm's execution on a predefined cubic graph. 1. Visualization Method Core Implementation public class CubicGraphExperimentService { public void CreateLollipopStepsVisualization(string graphString) { // Convert input string to adjacency matrix var adjacencyMatrix = GetMatrixFromNeighborsString(graphString); // Initialize graph structures var cubicGraph = new CubicGraph(adjacencyMatrix); var cubicGraphWithCycle = new CubicGraphWithCycle(cubicGraph); // Generate visualization LollipopAlgorithm.CreateLollipopVisualization(cubicGraphWithCycle); } } 2. Input Format The method accepts graphs in a specific string format: \"1,33,32_0,2,31_1,3,30_..._31,33,0_32,0,4\" Each X,Y,Z segment represents a vertex's neighbors Segments are separated by underscores (_) Vertex numbering starts at 0 3. Result After executing the visualization method, the system generates all necessary files in the VisualizationSteps directory in the root of calling project To view the algorithm visualization find the index.html and launch it"
  },
  "index.html": {
    "href": "index.html",
    "title": "Thomason Algorithm Documentation | Thomason Algorithm Documentation",
    "summary": "Thomason Algorithm Documentation Welcome to the documentation for ThomasonAlgorithm.Core, a .NET library for analyzing cubic graphs using Thomason's algorithm. Overview ThomasonAlgorithm.Core is a .NET library designed for the analysis of Hamiltonian cubic graphs (3-regular graphs containing at least one Hamiltonian cycle) with a focus on Thomason's algorithmic approaches. The library specializes in graphs where: The primary Hamiltonian cycle follows a sequential path: 0 → 1 → 2 → ... → n-1 → 0 (where n is the number of vertices). Cubic constraints are enforced: every vertex has exactly three edges. Key features include: Generation of random cubic graphs with constraints on chord lengths. Analysis of Hamiltonian cycles and step-by-step execution of the Lollipop Algorithm. Tools for evaluating and recording the lengths of chords (edges not part of the Hamiltonian cycle) and their distribution. A flexible experiment pipeline for systematically testing large numbers of graph instances with varying parameters. Extension methods and utilities for working with graphs represented via adjacency matrices. This library is well-suited for research and educational purposes related to Hamiltonian graph theory, and supports customization for testing different configurations and properties of chord sets in cubic graphs. Navigation Getting Started API Reference Cubic Graph Experiment Demo Lollipop visualization example"
  }
}